# Использование топиков

Вы можете подписывать устройства и реестры на топики `$<devices_или_registries>/<идентификатор_устройства_или_реестра>/events` и `$<devices_или_registries>/<идентификатор_устройства_или_реестра>/commands`.

Если у вас есть устройства, на показания датчиков которых нужно оперативно реагировать, а в вашей сети возможны перебои со связью и разрыв соединения между устройствами и [MQTT-сервером](../../../glossary/mqtt-server.md), подписывайте устройства и реестры на перманентные топики `$<devices_или_registries>/<идентификатор_устройства_или_реестра>/state` и `$<devices_или_registries>/<идентификатор_устройства_или_реестра>/config`. В перманентном топике сохраняется последнее сообщение, отправленное в этот топик, и отображается при возобновлении соединения (даже если в момент подключения в топик не пишут устройства и реестры). После возобновления соединения перманентные топики работают как обычные топики, информация в них появляется когда устройство или реестр в них пишет.

В таблице описаны действия, которые устройства и реестры совершают с топиками:

Топики | Устройство | Реестр
----|----|----
`$devices/<идентификатор_устройства>/events` <br/><br/>`$devices/<идентификатор_устройства>/state` | Отправляет телеметрические данные. | Получает телеметрические данные. <br/>Устройство известно.
`$devices/<идентификатор_устройства>/commands` <br/><br/>`$devices/<идентификатор_устройства>/config` | Получает команды. | Отправляет команды определенному устройству.
`$registries/<идентификатор_реестра>/events` <br/><br/>`$registries/<идентификатор_реестра>/state` | Отправляет телеметрические данные. | Получает телеметрические данные от всех устройств в реестре.<br/>Устройство неизвестно.
`$registries/<идентификатор_реестра>/commands` <br/><br/>`$registries/<идентификатор_реестра>/config` | Получает команды. | Отправляет команды всем устройствам в реестре.
`$monitoring/<идентификатор_устройства>/json` | Получает данные мониторинга другого устройства в формате JSON. | Получает данные мониторинга устройства в формате JSON.

## Использование алиасов для топиков {#aliases}

_Алиас_ — это псевдоним [топика устройства](./devices-topic.md), присвоенный пользователем. Алиасы можно присваивать стандартным топикам, которые уже есть в сервисе, а также топикам с произвольными сабтопиками.

{% include [monitoring-topic](../../../_includes/iot-core/monitoring-topic.md) %}

Алиас задается в формате ключ-значение:

```
<алиас>='<топик_устройства>'
```

Алиасы можно использовать для отправки сообщений и подписки на сообщения наравне с обычными топиками устройств. Также вы можете использовать в алиасах символы подстановки при подписке на сообщения, при этом проверяется формат исходного топика, которому был присвоен алиас.

Алиас должен однозначно определять устройство, то есть топик, которому присваивается алиас, должен содержать уникальный идентификатор устройства.

> Если [создать алиас](../../operations/device/alias/alias-create.md) `my/alias/=$devices/<идентификатор_устройства>/`, то можно использовать топик `my/alias/events`. Он будет эквивалентен `$devices/<идентификатор_устройства>/events`. По аналогии можно использовать и другие топики, начинающиеся с `$devices/<идентификатор_устройства>/`.

В рамках одного реестра алиасы не могут совпадать с префиксами других алиасов.

> Если вы создали алиас `my/alias/=...`, в этом реестре вы не сможете создать алиасы `my/=...`, `my/alias/2/=...`, `my/ali=...`.

> Вы можете создать алиасы `my/alias1/=...`, `my/alias2/=...` или `my/ali/=...`.

## Использование системных алиасов $me в $me-топиках {#mealias}

Чтобы каждый раз не вводить идентификатор устройства, от имени которого открыта MQTT-сессия, вы можете использовать $me-топики на основе алиасов `$me`, уже созданных в сервисе.

$me-топик | Эквивалентный топик
----|----
`$me/device/events` | `$devices/<идентификатор_устройства>/events`
`$me/device/commands` | `$devices/<идентификатор_устройства>/commands`
`$me/device/state` | `$devices/<идентификатор_устройства>/state`
`$me/device/config` | `$devices/<идентификатор_устройства>/config`
`$me/registry/commands` | `$registries/<идентификатор_устройства>/commands`
`$me/registry/config` | `$registries/<идентификатор_устройства>/config`
`$me/monitoring/json`| `$monitoring/<идентификатор_устройства>/json`

При отправке сообщений и подписке на сообщения, $me-топики преобразуются в топики с `<идентификатор_устройства>` на уровне MQTT.
Если вы подписались на $me-топик, данные вы тоже получите в $me-топике.

## Подписка на топики с использованием символов подстановки {#wildcards}

Вы можете использовать специальные символы подстановки `#` и `+`, которые позволяют фильтровать подписки на топики.

Если в начале фильтра стоит `$devices/`, то в фильтр попадают топики устройств, а если `$registries/`, то топики реестров. В остальных случаях в фильтр попадают только алиасы.

{% note info %}

Подписка на алиасы перманентных топиков с использованием символов подстановки работает как подписка на обычные топики. При возобновлении подключения к MQTT-серверу текущее состояние топика не отправляется подписанным на него реестрам или устройствам.

Если при подписке на перманентные топики с использованием символов подстановки в фильтр попадают более тысячи топиков, доставка данных по всем топикам не гарантируется.

{% endnote %}

### Символ # {#sharp}

Означает подстановку одной или нескольких частей топика, а также пустой строки. Всегда является последним символом в фильтре.

Примеры использования символа `#`:

* `#` — подписаться на все алиасы топиков.
* `$devices/#` — подписаться на все топики всех устройств.
* `$devices/<идентификатор_устройства>/#` — подписаться на все топики определенного устройства.
* `$devices/<идентификатор_устройства>/events/#` — подписаться на все топики определенного устройства с телеметрическими данными.
* `$devices/<идентификатор_устройства>/state/#` — подписаться на все перманентные топики с телеметрическими данными устройства с указанным уникальным идентификатором.

### Символ + {#plus}

Означает подстановку одной части топика между символами `/` либо в конце после символа `/`.

Например, по подписке `$registries/<идентификатор_реестра>/commands/+` устройства получат команды, отправленные в топики `$registries/<идентификатор_реестра>/commands/bedroom` и `$registries/<идентификатор_реестра>/commands/kitchen`, но проигнорируют команду в топик `$registries/<идентификатор_реестра>/commands/bedroom/entrance`.

Примеры использования символа **+**:

* `$devices/<идентификатор_устройства>/+` — подписаться на все топики определенного устройства с телеметрическими данными и командами.
* `$devices/<идентификатор_устройства>/events/+` — подписаться на все топики определенного устройства с телеметрическими данными из всех помещений. Предполагается, что в примере символ `+` замещает помещение.
* `$devices/+/events/bedroom/temperature` — подписаться на все топики всех устройств с телеметрическими данными о температуре в спальне.
* `$devices/+/events/bedroom/+` — подписаться на все топики всех устройств с телеметрическими данными в спальне. Предполагается, что в примере символы `+` замещают уникальный идентификатор устройства и тип датчика.

Фильтры `$devices/+` и `$registries/+` не работают, т.к. топик должен состоять из трех частей: `$<devices_или_registries>/<идентификатор_устройства_или_реестра>/<events_или_commands>`.

### Совместное использование символов + и # {#join}

После `+` можно использовать `#`, чтобы подставить остальную часть топика или сабтопика:

* `$devices/+/#` — подписаться на все топики всех устройств. Эквивалентен фильтру `$devices/#`.

* `$devices/+/events/#` — подписаться на все топики всех устройств с телеметрическими данными.

При фильтрации также учитываются общие правила подписки на топики, например:

* Подписка на фильтр `$devices/#` с [сертификатом реестра](../../operations/certificates/registry-certificates.md) эквивалентна подписке на `$devices/+/events/#`.

   При этом будут получены и все сообщения, отправленные в `$devices/<идентификатор_устройства>/events`.

* Подписка на фильтр `$registries/#` с [сертификатом устройства](../../operations/certificates/device-certificates.md) эквивалентна подписке на `$registries/<идентификатор_реестра>/commands/#`.

   При этом будут получены и все сообщения, отправленные в `$registries/<идентификатор_реестра>/commands`.

## Триггеры для топиков {#trigger}

_Триггер_ — условие, при наступлении которого автоматически запускается определенная функция или контейнер.

Триггер для {{ iot-short-name }} предназначен для управления сообщениями, которыми обмениваются устройства и реестры. Он создается для топиков: принимает из них копии сообщений и передает в [функцию](../../../functions/concepts/function.md) {{ sf-name }} или [контейнер](../../../serverless-containers/concepts/container.md) {{ serverless-containers-name }} для обработки.  

{% include [trigger](../../../_includes/iot-core/trigger.md) %}

Триггеру для {{ iot-short-name }} необходим [сервисный аккаунт](../../../iam/concepts/users/service-accounts.md) для вызова функции или контейнера.

Подробнее о триггерах читайте в документации [{{ sf-name }}](../../../functions/concepts/trigger/index.md) и [{{ serverless-containers-name }}](../../../serverless-containers/concepts/trigger/index.md).

## Экспорт в {{ yds-name }} {#yds-export}

Вы можете [настроить экспорт сообщений](../../operations/yds-export.md) из топиков реестра и топиков устройств в [поток данных](../../../data-streams/concepts/glossary.md#stream-concepts) {{ yds-full-name }}, чтобы затем передавать полученные данные в другие сервисы и приложения для последующего анализа и обработки. Поддерживается настройка только одного экспорта для реестра.

{% note info %}

Экспортировать сообщения из топиков брокера нельзя.

{% endnote %}

Данные экспортируются в следующем формате:

```json
{
  "device_id": "<идентификатор_устройства",
  "mqtt_topic": "<топик>",
  "payload": "<текст_сообщения>",
  "is_base64": true|false
}
```

Где:

* `device_id` — идентификатор устройства, которое отправляет данные в топик. Если сообщение отправляет реестр, это поле остается пустым.
* `mqtt_topic` — топик, из которого экспортируется сообщение.
* `payload` — текст сообщения;
* `is_base64` — принимает значение `true`, если сообщение закодировано в [Base64](https://ru.wikipedia.org/wiki/Base64), в противном случае — `false`. Сообщение кодируется в Base64, если оно имеет некорректную кодировку [UTF-8](https://ru.wikipedia.org/wiki/UTF-8).
